package ExplorationAlgorithms{
interface MazeSolver {
    + solveMaze()
}


class BreadthFirstSearchSolver {
}

class RightHandExploration {
}

MazeSolver <|.. BreadthFirstSearchSolver
MazeSolver <|.. RightHandExploration

 class AlgorithmInstructions {
        - path: Path

        + AlgorithmInstructions(path: Path)
        + instructForward()
        + instructRight()
        + instructLeft()
        + instructBackwards()
        + factorizeInstructions(): String
    }
}

package Entity{

class Node {
    + Node(x: int, y: int)
    + getX(): int
    + getY(): int
}

interface PlayerExplorer {
        + turnRight()
        + turnLeft()
        + turnBackwards()
        + moveForward()
    }

class Player {
        
    }

PlayerExplorer <|.. Player
}


package Mazes{

enum Tile{
    WALL,
    PASS
}


interface Maze {
    + getMazeWidth(): int
    + getMazeHeight(): int
    + getNeighbouringTiles(row: int, col: int): Map<Direction, Boolean>
    + isPassTile(row: int, col: int): boolean
    + getRowCoordinates(): List<Integer>
}


class MazeMatrix {
        + Maze(filepath: Path)
    }


class MazeExporter {
        - filePath: StringBuilder
        
        + MazeExporter(fp: Path)
        + constructMaze(): Tile[][]
    }

 class MazeSolverFactory {
        + createSolver(userEnteredAlgorithm: String, maze: Maze): MazeSolver
    }

MazeMatrix..|> Maze

}



package Paths{

class Path {
        - path: StringBuilder
        
        + Path()
        + Path(path: String)
        + getPath(): StringBuilder
        + addInstruction(instruction: String): void
        + getPathLength(): int
        + getLastInstruction(): char
    }

class PathChecker {
        - maze: Maze
        
        + PathChecker(maze: Maze)
        + getEntranceAndExit(): List<Integer>
        + canMoveLeft(player: Player): boolean
        + canMoveRight(player: Player): boolean
        + canMoveForward(player: Player): boolean
        + canFollowInstruction(instruction: Direction, player: Player): boolean
    }
}

package Utils{

enum Direction {
    NORTH
    EAST
    SOUTH
    WEST
    F
    R
    L
}

enum Algorithms {
        RIGHTHAND
        BFS
        BAD_ALGORITHM
    }

class Compass {
        + getRelativeDirection(currentOrientation: Direction, newOrientation: Direction): Direction
    }
}

package Verifiers{

interface BenchMark {
    + benchMark(userEnteredBaseLine: String, userEnteredMethod: String): void
}

interface InputVerifier {
    + verifyPath(): String
}

interface FactorizedVerifier {
    + verifyFactorized(startWest: boolean): boolean
}

interface CannonicalVerifier {
    + isCannonical(): boolean
    + verifyCannonical(startWest: boolean): boolean
}

class MazeInputReader {
    }


MazeInputReader ..|> InputVerifier
MazeInputReader ..|> FactorizedVerifier
MazeInputReader ..|> CannonicalVerifier


class BenchMarker {
     
    }

BenchMarker ..|> BenchMark

}




Mazes -[hidden]> Utils
Mazes -[hidden]> Entity 

Mazes-[hidden]--------> ExplorationAlgorithms 
Utils-[hidden]---> Verifiers
Entity -[hidden]---> Paths


ExplorationAlgorithms -[hidden]> Verifiers
ExplorationAlgorithms -[hidden]> Paths

BreadthFirstSearchSolver o-- MazeMatrix
BreadthFirstSearchSolver o-- AlgorithmInstructions
BreadthFirstSearchSolver o-- Node
BreadthFirstSearchSolver o-- Compass


BenchMarker o-- MazeSolver
BenchMarker o-- MazeSolverFactory
BenchMarker o-- Maze

RightHandExploration o-- Maze

RightHandExploration o-- AlgorithmInstructions
RightHandExploration o-- Player

